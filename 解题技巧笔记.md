# 解题笔记
* 记录解题中遇见的好思路、好方法

### 递归调用解题方法
* 三道题套路解决递归问题
https://lyl0724.github.io/2020/01/25/1/
既然递归是一个反复调用自身的过程，这就说明它每一级的功能都是一样的，因此我们只需要关注一级递归的解决过程即可。

**因此，也就有了我们解递归题的三部曲：**

1. **找整个递归的终止条件：递归应该在什么时候结束？**
2. **找返回值：应该给上一级返回什么信息？**
3. **本级递归应该做什么：在这一级递归中，应该完成什么任务？**

**一定要理解这3步，这就是以后递归秒杀算法题的依据和思路。**

### 检测链表是否有环，可使用快慢指针法
https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/

意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的慢的称为 “乌龟”，跑得快的称为 “兔子”。

不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。

### 哈希
当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

- 数组
- set （集合）
- map(映射)

哈希set示例
```c
struct unordered_set {
    int key;
    UT_hash_handle hh;
};

//尽量不要使用全局变量
//struct unordered_set *set1 = NULL;

struct unordered_set* find(struct unordered_set** hashtable, int ikey) {
    struct unordered_set* tmp;
    HASH_FIND_INT(*hashtable, &ikey, tmp);
    return tmp;
}

void insert(struct unordered_set** hashtable, int ikey) {
    //struct unordered_set* tmp = find(hashtable, ikey);
    //if (tmp != NULL) return;
    struct unordered_set* tmp = NULL;
    tmp = malloc(sizeof(struct unordered_set));
    tmp->key = ikey;
    HASH_ADD_INT(*hashtable, key, tmp);
}

find(&set1,sum);
insert(&set1,sum);
```